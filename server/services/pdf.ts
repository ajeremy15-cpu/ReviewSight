import PDFDocument from "pdfkit";
import { storage } from "../storage";

class PdfService {
  async generateWeeklyReport(organizationId: string): Promise<Buffer> {
    try {
      // Get organization data
      const organization = await storage.getOrganization(organizationId);
      if (!organization) {
        throw new Error("Organization not found");
      }

      // Get analytics data
      const reviews = await storage.getReviews(organizationId, { limit: 1000 });
      const aspectScores = await storage.getAspectScores(organizationId);
      const insights = await storage.getInsights(organizationId);

      // Calculate metrics
      const totalReviews = reviews.length;
      const avgRating = totalReviews > 0 
        ? reviews.reduce((sum, r) => sum + r.rating, 0) / totalReviews 
        : 0;
      const positiveReviews = reviews.filter(r => r.rating >= 4).length;

      // Create PDF
      const doc = new PDFDocument({ margin: 50 });
      const chunks: Buffer[] = [];

      doc.on('data', chunk => chunks.push(chunk));

      // Header
      doc.fontSize(24)
         .text(`Weekly Review Report - ${organization.name}`, { align: 'center' });
      
      doc.moveDown();
      doc.fontSize(12)
         .text(`Generated on ${new Date().toLocaleDateString()}`, { align: 'center' });

      doc.moveDown(2);

      // Key Metrics Section
      doc.fontSize(16)
         .text('Key Metrics', { underline: true });
      
      doc.moveDown();
      doc.fontSize(12)
         .text(`Total Reviews: ${totalReviews}`)
         .text(`Average Rating: ${avgRating.toFixed(1)}/5`)
         .text(`Positive Reviews: ${positiveReviews} (${totalReviews > 0 ? ((positiveReviews / totalReviews) * 100).toFixed(1) : 0}%)`);

      doc.moveDown(2);

      // Aspect Scores Section
      if (aspectScores.length > 0) {
        doc.fontSize(16)
           .text('Aspect Performance', { underline: true });
        
        doc.moveDown();
        
        const aspectMap = new Map();
        aspectScores.forEach(score => {
          const key = score.aspect;
          if (!aspectMap.has(key)) {
            aspectMap.set(key, { positive: 0, total: 0 });
          }
          const data = aspectMap.get(key);
          data.total += parseInt(score.count);
          if (score.sentiment === 'POS') {
            data.positive += parseInt(score.count);
          }
        });

        Array.from(aspectMap.entries()).forEach(([aspect, data]) => {
          const score = data.total > 0 ? Math.round((data.positive / data.total) * 100) : 0;
          doc.fontSize(12)
             .text(`${aspect}: ${score}%`);
        });

        doc.moveDown(2);
      }

      // Recent Insights Section
      if (insights.length > 0) {
        doc.fontSize(16)
           .text('Key Insights', { underline: true });
        
        doc.moveDown();
        
        insights.slice(0, 3).forEach((insight, index) => {
          doc.fontSize(12)
             .text(`${index + 1}. ${insight.title}`, { fontWeight: 'bold' })
             .text(`   ${insight.summary}`)
             .text(`   Severity: ${insight.severity}`)
             .moveDown();
        });
      }

      // Recent Reviews Section
      const recentReviews = await storage.getReviewsWithSources(organizationId, 5);
      if (recentReviews.length > 0) {
        doc.fontSize(16)
           .text('Recent Reviews', { underline: true });
        
        doc.moveDown();
        
        recentReviews.forEach((review, index) => {
          doc.fontSize(12)
             .text(`${index + 1}. ${review.source.name} - ${review.rating}/5 stars`)
             .text(`   Author: ${review.author || 'Anonymous'}`)
             .text(`   "${review.text.substring(0, 150)}${review.text.length > 150 ? '...' : ''}"`)
             .moveDown();
        });
      }

      // Footer
      doc.fontSize(10)
         .text('Generated by ReviewScope Analytics Platform', 50, doc.page.height - 50, { align: 'center' });

      doc.end();

      return new Promise<Buffer>((resolve, reject) => {
        doc.on('end', () => {
          resolve(Buffer.concat(chunks));
        });
        doc.on('error', reject);
      });

    } catch (error) {
      console.error("Error generating PDF report:", error);
      throw new Error("Failed to generate PDF report");
    }
  }
}

export const pdfService = new PdfService();